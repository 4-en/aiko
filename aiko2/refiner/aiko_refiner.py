from .base_refiner import BaseRefiner
from aiko2.core import Conversation, Message
import re

class AikoRefiner(BaseRefiner):
    """
    A test refiner to test pipeline functionality.
    """
    
    # Define the replacements dictionary, including new anime-fox/Senko-san inspired mappings.
    replacements = {
        "now":        "nyow",
        "hello":      "hewwo",
        "nice":       "nyice",
        "good":       "gwood",
        "great":      "gweat",
        "hi":         "hai",
        "hey":        "hai",
        "bye":        "byebye",
        "sorry":      "sowwy",
        "love":       "wuv",
        "really":     "weally",
        "what":       "nani",
        "yes":        "yus",
        "no":         "nu",
        "friend":     "fwend",
        "cute":       "kawaii",
        "cool":       "coow",
        "sleep":      "sweep",
        "eat":        "nom nom",
        "food":       "nyum-nyum",
        
        # Additional fox-like and Senko-san inspired replacements:
        "fox":        "kitsune",
        "fluffy":     "fuwafuwa",
        "sleepy":     "sweepy",
        "maybe":      "may-kon",
        "thanks":     "thankyuwu",
        "thank":      "thankyuwu",
        "play":       "pway",
        "adorable":   "adawable",
        "snuggle":    "snuggly-wuggly",
        "hug":        "huggies",
        "amazing":    "sugoi",
        "lucky":      "wucky",
        "hungry":     "nummy",
        "tired":      "tiwed",
        "scared":     "scawy",
        "excited":    "excito",
        "dinner":     "din-din",
        "lunch":      "wunch",
        "breakfast":  "brekky",
        "snack":      "snax",
    }
    
    def replacement_func(self, match, selected_positions):
        # Replace only if this match's start index was selected.
        if match.start() in selected_positions:
            word = match.group(0)
            # Get the replacement by looking up the lowercase version of the word.
            repl = AikoRefiner.replacements[word.lower()]
            # Preserve the original capitalization:
            if word.isupper():
                return repl.upper()
            elif word[0].isupper():
                return repl.capitalize()
            else:
                return repl
        else:
            # Otherwise, leave the original word unchanged.
            return match.group(0)
    
    def refine(self, conversation: Conversation, response: Message) -> Message:
        """
        Refine the response generated by the generator.

        Parameters
        ----------
        conversation : Conversation
            The conversation object containing the context of the conversation.
        response : Message
            The response generated by the generator.

        Returns
        -------
        Message
            The refined response.
        """
        
        content:str = response.content
        
    

        # Build a regex pattern to match any of the keys as whole words (case-insensitive).
        pattern = re.compile(r'\b(' + '|'.join(map(re.escape, AikoRefiner.replacements.keys())) + r')\b', re.IGNORECASE)

        # --- Compute the Replacement Budget & Spacing ---

        # Calculate the total number of words in the content.
        total_words = len(content.split())

        # Set a replacement limit based on a fraction of the word count.
        # Here we use 5% of the total words, with a minimum of one replacement.
        allowed_replacements = max(1, int(total_words * 0.1))

        # Determine a minimum spacing (in characters) between replacements.
        # This ensures that the selected replacements are spread roughly evenly.
        min_spacing = int(len(content) / allowed_replacements * 0.9)

        # --- Select Which Matches to Replace ---

        # Use re.finditer to collect all matches (they are returned in order).
        selected_positions = set()
        last_replaced_pos = -min_spacing  # Initialize so the first match qualifies.
        replacements_used = 0

        for match in pattern.finditer(content):
            if replacements_used < allowed_replacements:
                # Only select this match if itâ€™s at least min_spacing characters from the previous replacement.
                if match.start() - last_replaced_pos >= min_spacing:
                    selected_positions.add(match.start())
                    last_replaced_pos = match.start()
                    replacements_used += 1

        # Apply the substitutions to create a new, fox-like version of the text.
        new_content = pattern.sub(lambda x: self.replacement_func(x, selected_positions), content)
        
        # Return the refined response
        return Message(new_content, response.user, response.timestamp)
            